# 1. Role
너는 스프링부트 전문가이자 TMForum spec을 잘 알고 있는 통신 비즈니스 전문가야.

# 2. architecture
- Springboot & JPA & QueryDSL기반의 hexagonal architecture

# 3. 개발 규칙
- DTO는 record로 생성
- Lombok을 사용하여 boilerplate code 최소화
- 잘 지어진 변수,메소드명 유지. 깔끔한 코드 유지

# 4. 목적
- 이동통신 시스템의 요금계산 로직 구현. OCP원칙 준수

# 5. 월정액료 비즈니스 규칙
## 5.1. 상품 가입 이력이 존재하고 사용일만큼 일할 계산. (가입일은 사용기간에 포함, 해지일은 사용기간에서 제외)
## 5.2. 정지 기간은 상품 별로 정의된 정지시 과금요율에 따라 계산.
## 5.3. 상품 가입 이력과 상품 상태(사용중, 정지 등) 이력 구간을 중첩시켜야 해. 그래야 이후에 그 나뉘어진 구간별로 할인을 적용해 줄 수 있어. B2B상품은 구간을 분리할 때 참조해야 할 데이터가 추가로 존재할 수 있어.
### 예제 : 5월 사용분에 대한 요금을 계산한다고 가정. 
- A상품을 5월 16일 16:00까지 사용.
- B상품을 5월 16일 16:00부터 사용.
- 5월 1일 부터 5월 10일 14:00까지 사용.
- 5월 10일 14:00부터 5월 13일 18:00까지 정지.
- 5월 13일 18:00부터 계속 사용
위와 같은 경우에는 아래처럼 구간이 생겨야 해.
| 상품 | 계산시작일 | 계산종료일 | 상태 |
|---|---|---|---|
| A | 5/1 | 5/9(해지일 비산입) | 사용중 |
| A | 5/10 | 5/12(종료일 비산입) | 정지 | 
| A | 5/13 | 5/15(해지일 비산입) | 사용중 |
| B | 5/16 | 5/31 | 사용중 |
## 5.4. 상품 별로 과금 정책 상이. 간단하게는 flat요금, 일부 B2B 상품들은 과금에 영향을 주는 추가 요소들 존재
앞으로 새로운 유형의 B2B상품이 추가되도 OCP원칙에 의거하여 기존 코드는 수정 없이 설계해야함 (strategy 패턴 사용)
## 5.5. 대부분의 상품 과금 정책은 flat형임. 다만 요금만 다름.
## 5.6. 아래는 현재까지 도출된 B2B 상품의 과금 정책. 상품 가입 이력처럼 이력성 데이터라서 일할계산 대상.
- n개의 과금요소가 기준정보와 일치하면 그 요금 사용. 과금요소는 이력성 데이터라서 일할계산 대상.
- 가입자별 계약금액 사용. 계약금액은 이력성 데이터라서 일할계산 대상.
- 특정 과금요소의 범위를 만족하면 그 요금을 택하는 유형. 과금요소는 이력성 데이터라서 일할계산 대상.
- 특정 과금요소와 단가를 곱하는 유형. 과금요소는 이력성 데이터라서 일할계산 대상.
## 5.6. 계산 기간은 한달을 넘지 않음. (최대 1일~말일)

# 6. 일회성 과금 비즈니스 규칙
## 6.1. 매월 청구되는 할부금. 청구 후에는 청구여부를 db에 반영해줘야 함
## 6.2. 특정 이벤트 만족시 그달에만 한번 청구하는 요금 (여러가지 항목이 추후에 계속 추가될 수 있음)
일단 가입비와 약정위약금 두 가지가 있다고 가정

# 7. 부가세 비즈니스 규칙
## 7.1. 가입자별로 과세 정책 다름 (과세, 면세, 영세, 비과세)
## 7.2. 요금항목 별로 과세 정책 다름 (과세, 면세, 영세, 비과세)
## 7.3. 부가세율은 custom 가능

-----------------------

데이터를 조회하기 위해 mybatis를 사용할거야. 아래 순서대로 작업해줘.
# build.gradle에 관련 의존성을 추가해줘.
# domain submodule의 application.yml에 mybatis용 설정을 추가해줘.
# domain의 infrastructure, adapter 패키지를 만들어줘
# mybatis mapper xml에 findContractWithProductsChargeItemsAndSuspensions를 추가해줘.
## 입력
- contractId, billingStartDate, billingEndDate를 sql의 입력으로 받을거야.

## 출력
- Contract 하위에 product의 list와, suspension의 list를 보유
- product하위에는 MonthlyChargeItem의 list를 보유.

## join 조건
- contract의 contractId와 product의 contractId (inner join)
- product의 productOfferingId와 productoffering의 productOfferingId (inner join)
- contract의 contractId와 suspension의 contractId (outer join)

## filter 조건
- effectiveStartDateTime의 날짜부분 < effectiveEndDateTime의 날짜부분
- 모든 시작일스러운 값들은 <= billingEndDate의 23시59분59초 조건을, 모든 종료일스러운 값들은 > billingStartDate의 23시59분59초 조건을 넣어줘.
  시작일스러운 값들이 null이면 19000101로 치환, 종료일스러운 값들이 null이면 99991231로 치환해줘.

## 테이블 레이아웃
- 테이블 레이아웃은 domain안의 contractWithProductsAndSuspensions, product, suspension, productOffering, MonthlyChargeItem을 참고해줘.

위 테이블 조회 결과를 담는 dto는 infrastructure 계층에 위치해야 해.
이 다음 step으로 infrastructure의 dto를 domain 객체로 변환 로직을 만들거야. 일단 여기까지 해보자.

---------------

# mybatis sql xml을 만드는 부분에 key값 관련 오류가 있네. 아래 내용을 보완해줘.
1. contract의 key : contractId
2. product의 key : contractId, productOfferingId, effectiveStartDateTime, effectiveEndDateTime
3. suspension의 key : contractId, suspensionType, effectiveStartDateTime, effectiveEndDateTime
4. ProductOffering의 key : productId, chargeItemId

이 sql을 스프링배치에서 mybatispagingitemreader에서 쓸거니까 paging, 정렬조건을 잘 작성해줘.



-------------------

# Price 정보 관리 오브젝트 개발
- Spring Bean으로 관리
- ProductOfferingID와 MonthlyChargeItem의 조합으로 가격 정책 관리
- FlatRate면


--------------------

# 일회성과금 항목 계산 프로세스 개발
## package 추가
- domain, application 밑에 onetimecharge package 추가
- application.onetimecharge package에 policy package 추가
- domain.onetimecharge package에 policy package 추가
- domain.onetimecharge.policy package에 단말할부, 설치비 package 추가 (이름은 잘 지어줘)

## interface 추가
### application.onetimecharge package에 OneTimeChargeCalculator interface 추가
- 가변 클래스를 넣을 수 있게, I, O 라는 클래스 약어 도입.
- 아래 5개의 메소드 정의
1. List<I> read(CalculationRequest request)
2. O process(I input)
3. void write(List<O> output)
4. void post(List<O> output)
5. default method calculate
      default void calculate(CalculationRequest request) {
          write(read(request).stream().map(this::process).toList());
      }

## class 추가

### application.onetimecharge 에 OneTimeChargeCalculationResult, OneTimeChargeCalculationResultItem recode 추가 (1:n관계)
- OneTimeChargeCalculationResult : contractId, BillingStartDate, billingEndDate, list<OneTimeChargeCalculationResultItem> 보유
- OneTimeChargeCalculationResultItem : chargeItenCode, fee 보유

### application.onetimecharge.policy에 OneTimeChargeCalculator를 구현한 class 두개 추가. 메소드는 일단 비워둔다.
- 단말할부금 계산 (I : mybatis를 통해 조회한 할부내역DTO, O : OneTimeChargeCalculationResult)
- 설치비 계산 (I: mybatis를 통해 조회한 설치내역DTO, O : OneTimeChargeCalculationResult)

### domain.onetimecharge.policy에 domain entity 정의
- 단말할부마스터
|계약ID|할부일련번호|할부시작일|할부금총액|할부개월수|할부청구횟수|

- 단말할부상세 (단말할부마스터와 1:n관계)
|계약ID|할부일련번호|할부회차|할부금|청구완료일|

- 설치이력 (이름은 잘 지어줘)
|계약ID|일련번호|설치일|설치비|청구여부|


## mybatis xml, mapper 추가
### 단말할부내역 조회 로직을 단말할부내역 관리하는 mybatis xml에 추가
- 기존 contractWithProductsAndSuspensions reader 처럼 contractWithProductsAndSuspensions ID list를 받음
- 계약ID,할부일련번호를 key로 정의
- 조회조건 : 빌링종료일 >= 할부시작일 and 할부개월수 > 할부청구횟수

### 설치내역 조회 로직을 설치내역 관리하는 mybatis xml에 추가
- 기존 contractWithProductsAndSuspensions reader 처럼 contractWithProductsAndSuspensions ID list를 받음
- 계약ID,일련번호를 key로 정의
- 조회조건 : 빌링종료일 >= 설치일 and coalesce(청구여부,'N') = 'N'

### CalculationResultFlattener에 OneTimeChargeCalculationResult를 CalculationResult로 변환하는 로직 추가